{"ast":null,"code":"const createSbakeNode = function (x, y) {\n  let direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n  const cord = {\n    x,\n    y\n  };\n  const dir = direction;\n  return {\n    cord,\n    dir\n  };\n};\nconst moveSnakeNode = snakeNode => {\n  const {\n    cord: {\n      x,\n      y\n    },\n    dir: direction\n  } = snakeNode;\n  switch (direction.toString().toLowerCase()) {\n    case \"up\":\n      return {\n        x,\n        y: y - 1\n      };\n    case \"down\":\n      return {\n        x,\n        y: y + 1\n      };\n    case \"left\":\n      return {\n        x: x - 1,\n        y\n      };\n    case \"right\":\n      return {\n        x: x + 1,\n        y\n      };\n    default:\n      return {\n        x,\n        y\n      };\n  }\n};\nconst oportunityDirection = direction => {\n  switch (direction.toString().toLowerCase()) {\n    case \"up\":\n      return \"down\";\n    case \"down\":\n      return \"up\";\n    case \"left\":\n      return \"right\";\n    case \"right\":\n      return \"left\";\n  }\n};\nexport const moveSnake = function () {\n  let snake = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let direction = arguments.length > 1 ? arguments[1] : undefined;\n  if (!direction) {\n    return snake;\n  }\n  return [...snake].map((snakeNode, index) => {\n    if (index === snake.length - 1) {\n      snakeNode.dir = direction;\n      snakeNode.cord = moveSnakeNode(snakeNode);\n      return snakeNode;\n    }\n    snakeNode.dir = snake[index + 1].dir;\n    snakeNode.cord = moveSnakeNode(snakeNode);\n    return snakeNode;\n  });\n};\nexport const growSnake = function () {\n  let snake = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  const {\n    cord,\n    dir\n  } = snake[0];\n  const newDir = oportunityDirection(dir);\n  const newSnakeNode = {\n    cord,\n    dir\n  };\n  newSnakeNode.cord = moveSnakeNode({\n    cord,\n    dir: newDir\n  });\n  snake.unshift(newSnakeNode);\n  return snake;\n};\nexport const snakeEatItSeff = function () {\n  let snake = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  const last = snake.length - 1;\n  const {\n    x,\n    y\n  } = snake[last].cord;\n  const index = snake.findIndex(_ref => {\n    let {\n      cord\n    } = _ref;\n    return cord.x === x && cord.y === y;\n  });\n  return index !== last;\n};\nexport const snakeISOoutOfBounce = function () {\n  let snake = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let bordSize = arguments.length > 1 ? arguments[1] : undefined;\n  return snake.some(_ref2 => {\n    let {\n      cord: {\n        x,\n        y\n      }\n    } = _ref2;\n    return x >= bordSize || y >= bordSize || x < 0 || y < 0;\n  });\n};\nexport class Snake {\n  constructor(x, y) {\n    this.value = createSbakeNode(x, y);\n  }\n  grow() {}\n}","map":{"version":3,"names":["createSbakeNode","x","y","direction","cord","dir","moveSnakeNode","snakeNode","toString","toLowerCase","oportunityDirection","moveSnake","snake","map","index","length","growSnake","newDir","newSnakeNode","unshift","snakeEatItSeff","last","findIndex","snakeISOoutOfBounce","bordSize","some","Snake","constructor","value","grow"],"sources":["D:/FrontEnd/snake-game/src/utils/Snake.js"],"sourcesContent":["const createSbakeNode = (x, y, direction = \"\") => {\r\n  const cord = { x, y };\r\n  const dir = direction;\r\n  return { cord, dir };\r\n};\r\nconst moveSnakeNode = (snakeNode) => {\r\n  const {\r\n    cord: { x, y },\r\n    dir: direction,\r\n  } = snakeNode;\r\n  switch (direction.toString().toLowerCase()) {\r\n    case \"up\":\r\n      return { x, y: y - 1 };\r\n    case \"down\":\r\n      return { x, y: y + 1 };\r\n    case \"left\":\r\n      return { x: x - 1, y };\r\n    case \"right\":\r\n      return { x: x + 1, y };\r\n    default:\r\n      return { x, y };\r\n  }\r\n};\r\n\r\nconst oportunityDirection = (direction) => {\r\n  switch (direction.toString().toLowerCase()) {\r\n    case \"up\":\r\n      return \"down\";\r\n    case \"down\":\r\n      return \"up\";\r\n    case \"left\":\r\n      return \"right\";\r\n    case \"right\":\r\n      return \"left\";\r\n  }\r\n};\r\nexport const moveSnake = (snake = [], direction) => {\r\n  if (!direction) {\r\n    return snake;\r\n  }\r\n  return [...snake].map((snakeNode, index) => {\r\n    if (index === snake.length - 1) {\r\n      snakeNode.dir = direction;\r\n      snakeNode.cord = moveSnakeNode(snakeNode);\r\n      return snakeNode;\r\n    }\r\n    snakeNode.dir = snake[index + 1].dir;\r\n    snakeNode.cord = moveSnakeNode(snakeNode);\r\n    return snakeNode;\r\n  });\r\n};\r\nexport const growSnake = (snake = []) => {\r\n  const { cord, dir } = snake[0];\r\n  const newDir = oportunityDirection(dir);\r\n  const newSnakeNode = { cord, dir };\r\n  newSnakeNode.cord = moveSnakeNode({ cord, dir: newDir });\r\n  snake.unshift(newSnakeNode);\r\n  return snake;\r\n};\r\nexport const snakeEatItSeff = (snake = []) => {\r\n  const last = snake.length - 1;\r\n  const { x, y } = snake[last].cord;\r\n  const index = snake.findIndex(({ cord }) => cord.x === x && cord.y === y);\r\n  return index !== last;\r\n};\r\n\r\nexport const snakeISOoutOfBounce = (snake = [], bordSize) => {\r\n  return snake.some(\r\n    ({ cord: { x, y } }) => x >= bordSize || y >= bordSize || x < 0 || y < 0\r\n  );\r\n};\r\n\r\nexport class Snake {\r\n  constructor(x, y) {\r\n    this.value = createSbakeNode(x, y);\r\n  }\r\n\r\n  grow() {}\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}