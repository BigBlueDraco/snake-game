{"ast":null,"code":"var _this = this;\nconst createSbakeNode = function (x, y) {\n  let direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"left\";\n  const cord = {\n    x,\n    y\n  };\n  const dir = direction;\n  return {\n    cord,\n    dir\n  };\n};\nconst moveSnakeNode = function () {\n  let snakeNodedirection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  const {\n    x,\n    y\n  } = _this.head.val;\n  switch (direction.toString().toLowerCase()) {\n    case \"up\":\n      return {\n        x,\n        y: y - 1\n      };\n    case \"down\":\n      return {\n        x,\n        y: y + 1\n      };\n    case \"left\":\n      return {\n        x: x - 1,\n        y\n      };\n    case \"right\":\n      return {\n        x: x + 1,\n        y\n      };\n    default:\n      return {\n        x,\n        y\n      };\n  }\n};\nconst moveSnake = function () {\n  let snake = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let direction = arguments.length > 1 ? arguments[1] : undefined;\n  snake.map((snakeNode, index) => {\n    if (index >= snake.length() - 1) {\n      snakeNode.dir = direction;\n      snakeNode;\n    }\n  });\n};\nexport class Snake {\n  constructor(x, y) {\n    this.value = createSbakeNode(x, y);\n  }\n  grow() {}\n}","map":{"version":3,"names":["createSbakeNode","x","y","direction","cord","dir","moveSnakeNode","snakeNodedirection","head","val","toString","toLowerCase","moveSnake","snake","map","snakeNode","index","length","Snake","constructor","value","grow"],"sources":["D:/FrontEnd/snake-game/src/utils/Snake.js"],"sourcesContent":["const createSbakeNode = (x, y, direction = \"left\") => {\r\n  const cord = { x, y };\r\n  const dir = direction;\r\n  return { cord, dir };\r\n};\r\nconst moveSnakeNode = (snakeNodedirection = \"\") => {\r\n  const { x, y } = this.head.val;\r\n  switch (direction.toString().toLowerCase()) {\r\n    case \"up\":\r\n      return { x, y: y - 1 };\r\n    case \"down\":\r\n      return { x, y: y + 1 };\r\n    case \"left\":\r\n      return { x: x - 1, y };\r\n    case \"right\":\r\n      return { x: x + 1, y };\r\n    default:\r\n      return { x, y };\r\n  }\r\n};\r\n\r\nconst moveSnake = (snake = [], direction) => {\r\n  snake.map((snakeNode, index) => {\r\n    if (index >= snake.length() - 1) {\r\n      snakeNode.dir = direction;\r\n      snakeNode\r\n    }\r\n  });\r\n};\r\n\r\nexport class Snake {\r\n  constructor(x, y) {\r\n    this.value = createSbakeNode(x, y);\r\n  }\r\n\r\n  grow() {}\r\n}\r\n"],"mappings":";AAAA,MAAMA,eAAe,GAAG,UAACC,CAAC,EAAEC,CAAC,EAAyB;EAAA,IAAvBC,SAAS,uEAAG,MAAM;EAC/C,MAAMC,IAAI,GAAG;IAAEH,CAAC;IAAEC;EAAE,CAAC;EACrB,MAAMG,GAAG,GAAGF,SAAS;EACrB,OAAO;IAAEC,IAAI;IAAEC;EAAI,CAAC;AACtB,CAAC;AACD,MAAMC,aAAa,GAAG,YAA6B;EAAA,IAA5BC,kBAAkB,uEAAG,EAAE;EAC5C,MAAM;IAAEN,CAAC;IAAEC;EAAE,CAAC,GAAG,KAAI,CAACM,IAAI,CAACC,GAAG;EAC9B,QAAQN,SAAS,CAACO,QAAQ,EAAE,CAACC,WAAW,EAAE;IACxC,KAAK,IAAI;MACP,OAAO;QAAEV,CAAC;QAAEC,CAAC,EAAEA,CAAC,GAAG;MAAE,CAAC;IACxB,KAAK,MAAM;MACT,OAAO;QAAED,CAAC;QAAEC,CAAC,EAAEA,CAAC,GAAG;MAAE,CAAC;IACxB,KAAK,MAAM;MACT,OAAO;QAAED,CAAC,EAAEA,CAAC,GAAG,CAAC;QAAEC;MAAE,CAAC;IACxB,KAAK,OAAO;MACV,OAAO;QAAED,CAAC,EAAEA,CAAC,GAAG,CAAC;QAAEC;MAAE,CAAC;IACxB;MACE,OAAO;QAAED,CAAC;QAAEC;MAAE,CAAC;EAAC;AAEtB,CAAC;AAED,MAAMU,SAAS,GAAG,YAA2B;EAAA,IAA1BC,KAAK,uEAAG,EAAE;EAAA,IAAEV,SAAS;EACtCU,KAAK,CAACC,GAAG,CAAC,CAACC,SAAS,EAAEC,KAAK,KAAK;IAC9B,IAAIA,KAAK,IAAIH,KAAK,CAACI,MAAM,EAAE,GAAG,CAAC,EAAE;MAC/BF,SAAS,CAACV,GAAG,GAAGF,SAAS;MACzBY,SAAS;IACX;EACF,CAAC,CAAC;AACJ,CAAC;AAED,OAAO,MAAMG,KAAK,CAAC;EACjBC,WAAW,CAAClB,CAAC,EAAEC,CAAC,EAAE;IAChB,IAAI,CAACkB,KAAK,GAAGpB,eAAe,CAACC,CAAC,EAAEC,CAAC,CAAC;EACpC;EAEAmB,IAAI,GAAG,CAAC;AACV"},"metadata":{},"sourceType":"module","externalDependencies":[]}